void say(const char *fmt, ...);
void um(const char *fmt, ...);
ucell get_color(head *h, const char *name);
int error_callback(Display *dpy, XErrorEvent *ee);
ucell modifier_names_to_mask(char *names);
binding* find_binding(ucell mod, KeyCode key);
ubyte process_binding(char *pattern, ucell *m, KeyCode *k);
ubyte create_binding(char *pattern, char *command);
ubyte remove_binding(char *pattern);
void refresh_bindings();
int find_alias(char *name);
ubyte try_alias(char *name);
ubyte create_alias(char *name, char *command);
ubyte try_hook(char *cmd);
void atom_set(ucell atom, Window w, Atom type, int format, void *data, int items);
void atom_set_string(ucell atom, Window w, char *s);
ubyte atom_get_string(ucell prop, Window win, char **pad, ucell *plen);
ubyte atom_get(ucell atom, Window w, ubyte **data, ucell *items);
void window_name(Window win, char *pad);
void window_class(Window win, char *pad);
void window_role(Window win, char *pad);
ubyte is_netwmstate(ucell state, ucell atom);
ucell window_state(Window win);
ubyte is_unmanaged_class(char *name);
ubyte is_unmanaged_window(Window win);
ubyte window_on_screen(head *hd, Window win, XWindowAttributes *attr, int *x, int *y, int *w, int *h);
void window_stack(head *h, Window *list, int n);
ubyte sanity_window(Window *tree, ucell n, Window w);
int sanity_stack(stack *s, Window *tree, ucell num);
void sanity_head(head *h);
void sanity_heads();
void window_discard_references(Window w);
head* head_by_screen(Screen *s);
head* head_by_root(Window win);
client* client_by_window(Window w);
client* client_by_resize_window(Window w);
client* client_hidden(frame *f, ubyte direction, ubyte local, ubyte prefer);
frame* is_frame_background(Window win);
ubyte is_valid_client(client *c);
ubyte is_valid_frame(frame *f);
ubyte is_valid_group(group *c);
group* group_first(head *h);
group* group_last(head *h);
frame* frame_first(group *g);
frame* frame_last(group *g);
client* client_first(group *g);
client* client_last(group *g);
client* client_by_id(group *g, int id);
client* client_by_name(group *g, char *name);
client* client_from_string(group *g, char *s, client *def);
ubyte ewmh_client_visible(client *c);
void ewmh_clients();
void ewmh_groups();
void client_configure(client *c, XConfigureRequestEvent *cr);
void client_and_kids(client *c, stack *clients, client *except);
void client_display(client *c, frame *target);
void client_refresh(client *c);
void client_border(client *c, char *colour);
void client_unfocus(client *c);
void client_focus(client *c, frame *target);
void client_raise(client *c);
void client_show(client *c);
void client_hide(client *c);
void client_shrink(client *c);
void client_remove(client *c);
void client_kill(client *c);
void client_push(group *t, client *c);
void client_pop(client *c);
client* client_create(group *t, frame *f, Window win);
void client_destroy(client *c);
void client_regroup(group *g, client *c);
void frame_push(group *t, frame *f);
void frame_pop(frame *f);
ucell frame_border_focus(frame *f);
ucell frame_border_unfocus(frame *f);
frame* frame_create(group *t, int x, int y, int w, int h);
void frame_destroy(frame *f);
frame* frame_available(frame *f);
void frame_display_hidden(frame *f, ubyte direction, ubyte local, ubyte prefer);
void frame_focus_hidden(frame *f, ubyte direction, ubyte local, ubyte prefer);
void frame_auto_display_hidden(frame *f, ubyte direction);
void frame_auto_focus_hidden(frame *f, ubyte direction);
void frames_display_hidden(group *t);
void frame_update(frame *f);
void frame_unfocus(frame *f);
void frame_focus(frame *f);
void frame_target_client(frame *f, client *c);
void frame_focus_client(frame *f, client *c);
void frame_refocus_client(frame *f, client *c);
void frame_display_client(frame *f, client *c);
void frame_hide(frame *f);
frame* frame_hsplit(dcell ratio);
frame* frame_vsplit(dcell ratio);
void frame_split(ubyte direction, dcell ratio);
ubyte frame_borders(frame *s, int x, int y, int w, int h);
struct frame_match* frames_bordering(group *t, int x, int y, int w, int h);
ubyte frame_in_set(frame **set, frame *f);
void frames_fill_gap_except(group *t, frame **exceptions, int x, int y, int w, int h, ubyte mode);
void frames_fill_gap(group *t, int x, int y, int w, int h, ubyte mode);
ubyte nearest_side(int x, int y, int a, int b, int c, int d);
ubyte frame_covers(frame *s, int x, int y, int width, int height);
void frames_make_gap_except(group *t, frame **exceptions, int x, int y, int width, int height);
void frames_make_gap(group *t, int x, int y, int w, int h);
frame* frame_sibling(frame *f, ubyte axis, ubyte side);
frame** frame_siblings(frame *f, ubyte axis);
ubyte frame_siblings_growable(frame **siblings, ubyte axis, ucell size);
ubyte frame_siblings_shrinkable(frame **siblings, ubyte axis, ucell size);
void frame_remove();
ubyte frame_shrink(ubyte direction, ubyte adapt, ucell size);
ubyte frame_grow(ubyte direction, ubyte adapt, ucell size);
void frame_single(frame *f);
char frames_overlap_y(frame *a, frame *b);
char frames_overlap_x(frame *a, frame *b);
frame* frame_relative(frame *f, ubyte side);
void frame_left();
void frame_right();
void frame_up();
void frame_down();
void frame_swap(ubyte direction);
void frame_slide(ubyte direction);
void frame_dedicate();
void frame_catchall();
void group_push(head *h, group *t);
void group_pop(group *t);
group* group_create(head *head, char *name, int x, int y, int w, int h);
void group_destroy(group *t);
void group_unfocus(group *t);
void group_hide(group *t);
void group_focus(group *t);
void group_raise(group *g);
void group_next();
void group_prev();
void group_other();
void group_resize(group *ta, int l, int r, int t, int b);
group* group_by_name(head *h, char *name);
group* group_by_id(head *h, ucell id);
group* group_from_string(head *h, char *s, group *def);
group* group_auto_create(head *h, char *name);
char* group_dump(group *g);
void group_load(group *g, char *dump);
void group_track(group *g);
void group_undo(group *g);
void group_stack();
void head_focus(head *h);
void head_next();
void launch(char *cmd);
void menu(char *cmd, char *after);
void menu_wrapper(char *cmd, char *after);
void shutdown();
dcell parse_size(char *cmd, regmatch_t *subs, ucell index, ucell limit);
char* com_frame_split(char *cmd, regmatch_t *subs);
char* com_frame_size(char *cmd, regmatch_t *subs);
char* com_frame_resize(char *cmd, regmatch_t *subs);
char* com_group_pad(char *cmd, regmatch_t *subs);
char* com_group_add(char *cmd, regmatch_t *subs);
char* com_group_drop(char *cmd, regmatch_t *subs);
char* com_group_name(char *cmd, regmatch_t *subs);
char* com_window_to_group(char *cmd, regmatch_t *subs);
char* com_window_raise(char *cmd, regmatch_t *subs);
char* com_window_shrink(char *cmd, regmatch_t *subs);
char* com_refresh(char *cmd, regmatch_t *subs);
char* com_border(char *cmd, regmatch_t *subs);
char* com_frame_swap(char *cmd, regmatch_t *subs);
char* com_frame_slide(char *cmd, regmatch_t *subs);
char* com_group_dump(char *cmd, regmatch_t *subs);
char* com_group_load(char *cmd, regmatch_t *subs);
char* com_frame_remove(char *cmd, regmatch_t *subs);
char* com_frame_kill(char *cmd, regmatch_t *subs);
char* com_frame_cycle(char *cmd, regmatch_t *subs);
char* com_frame_only(char *cmd, regmatch_t *subs);
char* com_group_undo(char *cmd, regmatch_t *subs);
ubyte parse_flag(char *cmd, regmatch_t *subs, ucell index, ubyte current);
char* com_frame_dedicate(char *cmd, regmatch_t *subs);
char* com_frame_catchall(char *cmd, regmatch_t *subs);
char* com_frame_focus(char *cmd, regmatch_t *subs);
char* com_group_use(char *cmd, regmatch_t *subs);
char* com_exec(char *cmd, regmatch_t *subs);
char* com_manage(char *cmd, regmatch_t *subs);
char* com_screen_switch(char *cmd, regmatch_t *subs);
char* com_group_stack(char *cmd, regmatch_t *subs);
char* com_set(char *cmd, regmatch_t *subs);
char* com_bind(char *cmd, regmatch_t *subs);
char* com_switch(char *cmd, regmatch_t *subs);
char* com_command(char *cmd, regmatch_t *subs);
char* com_shell(char *cmd, regmatch_t *subs);
char* com_alias(char *cmd, regmatch_t *subs);
char* com_say(char *cmd, regmatch_t *subs);
char* com_run(char *cmd, regmatch_t *subs);
char* show_unmanaged();
char* show_bindings();
char* show_settings();
char* show_hooks();
char* show_groups();
char* show_frames();
char* show_windows();
char* show_aliases();
char* com_show(char *cmd, regmatch_t *subs);
char* com_hook(char *cmd, regmatch_t *subs);
char* com_client(char *cmd, regmatch_t *subs);
char* com_place(char *cmd, regmatch_t *subs);
char* com_debug(char *cmd, regmatch_t *subs);
char* com_quit(char *cmd, regmatch_t *subs);
ubyte run_file(char *file);
char* musca_command(char *cmd_orig);
char* musca_commands(char *content);
void window_switch();
void group_switch();
client* manage(Window win, XWindowAttributes *attr);
winstate* quiz_window(Window win);
void createnotify(XEvent *ev);
void configurerequest(XEvent *ev);
void configurenotify(XEvent *ev);
client* handle_map(winstate *ws);
void maprequest(XEvent *ev);
void mapnotify(XEvent *ev);
void unmapnotify(XEvent *ev);
void mappingnotify(XEvent *ev);
void destroynotify(XEvent *ev);
void enternotify(XEvent *ev);
void keypress(XEvent *ev);
void buttonpress(XEvent *ev);
void buttonrelease(XEvent *ev);
void motionnotify(XEvent *ev);
void propertynotify(XEvent *ev);
void clientmessage(XEvent *ev);
void focusin(XEvent *ev);
void focusout(XEvent *ev);
void leavenotify(XEvent *ev);
void timeout(int sig);
ubyte insert_command(char* cmd);
void find_window(Window w, ubyte transient);
void find_clients(head *h);
void ungrab_stuff();
void grab_stuff();
void setup_regex();
void setup_numlock();
void setup_bindings();
void setup_unmanaged();
void setup(int argc, char **argv);
void process_event(XEvent *ev);
int main(int argc, char **argv);
